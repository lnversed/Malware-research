#include <Windows.h>
#include <stdio.h>
#include <TlHelp32.h>

typedef struct IMAGE_BLOCK_DATA {
	DWORD BlockVirtualAddress;
	DWORD BlockSize;
} IMAGE_BLOCK_DATA, *PIMAGE_BLOCK_DATA;

typedef struct IMAGE_BLOCK_ENTRY {
	USHORT relocRVA : 12;
	USHORT relocType : 4;
} IMAGE_BLOCK_ENTRY, *PIMAGE_BLOCK_ENTRY;


int InjectionEntry(void) {
	return MessageBoxA(NULL, "alert", "test", NULL);
}

int getProcessID(LPCUWSTR processName) {
	HANDLE hsnapHandle = NULL;
	PROCESSENTRY32 pe32;

	hsnapHandle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	pe32.dwSize = sizeof(PROCESSENTRY32);
	if (!Process32First(hsnapHandle, &pe32)) {
		printf("Couldn't get process list.\n");
		CloseHandle(hsnapHandle);
		return 1;
	}

	do {
		if (wcscmp(processName, pe32.szExeFile) == 0) {
			DWORD processID = pe32.th32ProcessID;
			CloseHandle(hsnapHandle);
			return processID;
		}
	} while (Process32Next(hsnapHandle, &pe32));

	return 1;

}


int main(void) {
	LPCUWSTR processName = L"notepad.exe";
	DWORD processId;
	HANDLE hprocessHandle = NULL;
	LPVOID sourceImageBase = NULL;
	LPVOID sourceAlloc = NULL;
	LPVOID destinationAlloc = NULL;
	DWORD sourceImageSize = NULL;
	DWORDLONG deltaImageBase = NULL;

	processId = getProcessID(processName);

	if (processId == 1) {
		printf("Process not running.\n");
		return 1;
	}

	hprocessHandle = OpenProcess(MAXIMUM_ALLOWED, FALSE, processId);

	sourceImageBase = GetModuleHandleA(NULL);
	PIMAGE_DOS_HEADER sourceDOSHeader = (PIMAGE_DOS_HEADER)sourceImageBase;
	PIMAGE_NT_HEADERS sourceNTHeader = (PIMAGE_NT_HEADERS)((LPDWORD)sourceDOSHeader + sourceDOSHeader->e_lfanew / 4);
	sourceImageSize = sourceNTHeader->OptionalHeader.SizeOfImage;

	// copying source image to local memory
	sourceAlloc = VirtualAlloc(NULL, sourceImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!memcpy(sourceAlloc, sourceImageBase, sourceImageSize)) {
		printf("Unable to write to source process :(\n");
		CloseHandle(hprocessHandle);
		return 1;
	}

	// copying local memory (containing source image) to destination memory
	destinationAlloc = VirtualAllocEx(hprocessHandle, NULL, sourceImageSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!WriteProcessMemory(hprocessHandle, destinationAlloc, sourceAlloc, sourceImageSize, NULL)) {
		printf("Unable to write to destination process :(\n");
		CloseHandle(hprocessHandle);
		return 1;
	}


	deltaImageBase = (DWORD_PTR)sourceImageBase - (DWORD_PTR)destinationAlloc;
	PIMAGE_SECTION_HEADER sourceSectionHeader = (PIMAGE_SECTION_HEADER)((LPDWORD)sourceImageBase + sourceDOSHeader->e_lfanew / 4 + sizeof(IMAGE_NT_HEADERS) / 4);
	DWORD numberOfSections = sourceNTHeader->FileHeader.NumberOfSections;
	DWORD relocTable = sourceNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;

	LPDWORD relocBlockStart = (LPDWORD)sourceImageBase + relocTable / 4;
	DWORD relocOffset = NULL;
	

	while (relocOffset < sourceNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size) {
		PIMAGE_BLOCK_DATA relocBlockData = (PIMAGE_BLOCK_DATA)(relocBlockStart + relocOffset / 4);
		DWORD blockVirtualAddress = relocBlockData->BlockVirtualAddress;
		DWORD blockSize = relocBlockData->BlockSize / 2 - sizeof(IMAGE_BLOCK_DATA) / 2;
		relocOffset += sizeof(IMAGE_BLOCK_DATA);

		for (int y = 0; y < blockSize; y++) {
			PIMAGE_BLOCK_ENTRY relocBlockEntry = (PIMAGE_BLOCK_ENTRY)((LPDWORD)relocBlockStart + relocOffset/4);
			LPDWORD patchAddress = (LPDWORD)destinationAlloc + blockVirtualAddress / 4 + relocBlockEntry->relocRVA / 4;
			DWORD_PTR buff;
			
			if (!ReadProcessMemory(hprocessHandle, (LPCVOID)(patchAddress), &buff, sizeof(DWORD_PTR), NULL)) {
				printf("Couldn't read process memory at patch address\n");
				CloseHandle(hprocessHandle);
				return 1;
			}

			buff -= deltaImageBase;

			if (!WriteProcessMemory(hprocessHandle, (LPVOID)(patchAddress), &buff, sizeof(DWORD_PTR), NULL)) {
				printf("Couldn't write process memory at patch address\n");
				CloseHandle(hprocessHandle);
				return 1;
			}

			relocOffset += sizeof(IMAGE_BLOCK_ENTRY);

		}
			
	}

	DWORD_PTR thread_entry = (DWORD_PTR)&InjectionEntry;
	thread_entry -= deltaImageBase;
	CreateRemoteThread(hprocessHandle, NULL, 0, (LPTHREAD_START_ROUTINE)(thread_entry), NULL, 0, NULL);
	
	CloseHandle(hprocessHandle);
	return 0;
}